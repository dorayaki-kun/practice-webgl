<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>taiyaki sample</title>
  </head>
  <body>
    <canvas id="canvas" width="512" height="512"></canvas>
    <script id="vs" type="x-shader/x-vertex">
      attribute vec3 position;
      attribute vec2 textureCoord;

      uniform mat4 orthoMatrix;

      varying vec2 vTextureCoord;

      void main(){
        vTextureCoord   = vec2( textureCoord.x, textureCoord.y );
        gl_Position     = orthoMatrix * vec4( position, 1.0 );
      }
    </script>
    <script id="fs" type="x-shader/x-fragment">
      precision mediump float;

      uniform sampler2D texture;

      const float redScale        = 0.298912;
      const float greenScale      = 0.586611;
      const float blueScale       = 0.114478;
      const vec3  monochromeScale = vec3( redScale, greenScale, blueScale );

      const float sRedScale   = 1.07;
      const float sGreenScale = 0.74;
      const float sBlueScale  = 0.43;
      const vec3  sepiaScale = vec3(sRedScale, sGreenScale, sBlueScale);

      varying vec2 vTextureCoord;

      void main(){
        vec2 v  = vTextureCoord * 2.0 - 1.0;
        float l = 1.25 - length( v );

        vec3  smpColor  = texture2D( texture, vTextureCoord ).rgb;
        float gray      = dot( monochromeScale, smpColor );
        vec3 sepiaColor = vec3(gray) * sepiaScale;

        gl_FragColor = vec4( sepiaColor * l, 1.0 );
      }
    </script>
    <script id="light_vs" type="x-shader/x-vertex">
      attribute vec3 position;
      attribute vec3 normal;
      attribute vec4 color;

      uniform mat4 mvpMatrix;
      uniform mat4 invMatrix;
      uniform vec3 light;

      varying vec4 vColor;

      void main(){
        vec3 invLight = normalize( invMatrix * vec4( light, 1.0 ) ).xyz;
        float diff    = clamp( dot( invLight, normal ), 0.1, 1.0 );

        vColor = vec4( color.rgb * diff, 1.0 );

        gl_Position = mvpMatrix * vec4( position, 1.0 );
      }
    </script>
    <script id="light_fs" type="x-shader/x-fragment">
      precision mediump float;

      uniform sampler2D texture;

      varying vec4 vColor;

      void main(){
        gl_FragColor = vColor;
      }
    </script>
    <script type="text/javascript" src="./bundle.js"></script>
    <script type="text/javascript">
      function main() {
        var Context = taiyaki.RenderingContext;

        var ctx = new Context( 'canvas' );

        ctx.toggleDepthFunc( true );
        ctx.depthFunc();

        var bufferSize = 512;
        var frameBufferAttr = ctx.createFrameBuffer( bufferSize, bufferSize );

        var qt = quat.identity( quat.create() );

        render();

        function render() {
          var lightProgram = ctx.createProgram( [ 'light_vs', 'light_fs' ] );
          ctx.useProgram( lightProgram );

          var sphere = createSphere( 64, 64, 0.4, [ 0, 1, 0, 1 ] );

          setupVbos( lightProgram, sphere );
          initRender();
          setupUniforms( lightProgram );
          ctx.drawElements( ctx.gl.TRIANGLES, sphere.index.length );

          ctx.bindTexture( frameBufferAttr.texture, 0 );

          initOrthoRender();
          var program = ctx.createProgram( [ 'vs', 'fs' ] );
          ctx.useProgram( program );
          setupOrthoVbos( program );
          setupuOrthoUniforms( program );
          ctx.drawElements( ctx.gl.TRIANGLES, 6 );

          requestAnimationFrame( render );
        }

        function setupVbos( lightProgram, sphere ) {
          ctx.bindVbos(lightProgram,
            [
              { name: 'position',     value: sphere.position, stride: 3 },
              { name: 'normal',       value: sphere.normal,   stride: 3 },
              { name: 'color',        value: sphere.color,    stride: 4 },
            ]);

          ctx.bindIbo( sphere.index );
        }

        function initRender() {
          ctx.bindFramebuffer( frameBufferAttr.value );
          ctx.clear( { r: 0.3, g: 0.3, b: 0.3, a: 1 } );
          ctx.viewport({
            x:      0,
            y:      0,
            width:  bufferSize,
            height: bufferSize});
        }

        function setupUniforms( lightProgram ) {
          var vMatrix  = createVMatrix();
          var pMatrix  = createPMatrix();
          var vpMatrix = createVpMatrix( vMatrix, pMatrix );
          var mMatrix  = mat4.identity( mat4.create() );

          var mvpMatrix = createMvpMatrix( mMatrix, vpMatrix );
          var invMatrix = createInvMatrix( mMatrix );
          var light = [ 1, 1, 1 ];
          ctx.bindUniforms(
            lightProgram,
            [
              { name: 'mvpMatrix',      type: 'matrix4fv', value: mvpMatrix },
              { name: 'invMatrix',      type: 'matrix4fv', value: invMatrix },
              { name: 'light',          type: '3fv',       value: light }
            ]);
        }

        function createVMatrix() {
          var cx   = 1 * Math.sin( 0 );
          var cz   = 1 * Math.cos( 0 );

          var eyePosition    = quat.create();
          eyePosition[0] = cx;
          eyePosition[1] = 0;
          eyePosition[2] = cz;

          var centerPosition = [ 0.0, 0.0, 0.0 ];

          var cameraUp = quat.create();
          cameraUp[0] = 0;
          cameraUp[1] = 1;
          cameraUp[2] = 0;

          var rotatedEyePosition = new Array( 3 );
          convertToVec3( rotatedEyePosition, qt, eyePosition );

          var rotatedCameraUp = new Array( 3 );
          convertToVec3( rotatedCameraUp, qt, cameraUp );

          var vMatrix = mat4.identity( mat4.create() );
          mat4.lookAt( vMatrix, rotatedEyePosition, centerPosition, rotatedCameraUp );

          return vMatrix;
        }

        function createPMatrix() {
          var pMatrix = mat4.identity( mat4.create() );
          mat4.perspective( pMatrix, 45, 1, 0.1, 10 );
          return pMatrix;
        }

        function createVpMatrix( vMatrix, pMatrix ) {
          var vpMatrix = mat4.identity( mat4.create() );
          mat4.multiply( vpMatrix, pMatrix, vMatrix );
          return vpMatrix;
        }

        function createMvpMatrix( mMatrix, vpMatrix) {
          var mvpMatrix = mat4.identity( mat4.create() );
          mat4.multiply( mvpMatrix, vpMatrix, mMatrix );
          return mvpMatrix;
        }

        function createInvMatrix( mMatrix ) {
          var invMatrix = mat4.identity( mat4.create() );
          mat4.invert( invMatrix, mMatrix );
          return invMatrix;
        }

        function initOrthoRender() {
          ctx.bindFramebuffer( null );
          ctx.clear( { r: 0.3, g: 0.3, b: 0.3, a: 1 } );
          ctx.viewport({
            x:      0,
            y:      0,
            width:  canvas.width,
            height: canvas.height});
        }

        function setupOrthoVbos( program ) {
          var position = [
            -1,  1, 0,
             1,  1, 0,
            -1, -1, 0,
             1, -1, 0
          ]

          var textureCoord = [
            0.0, 0.0,
            1.0, 0.0,
            0.0, 1.0,
            1.0, 1.0
          ];

          var index = [
            0, 1, 2,
            2, 1, 3
          ];

          ctx.bindVbos(program,
            [
              { name: 'position',     value: position,     stride: 3 },
              { name: 'textureCoord', value: textureCoord, stride: 2 }
            ]);
          ctx.bindIbo( index );
        }

        function setupuOrthoUniforms( program ) {
          var vMatrix = createOrthoVmatrix();
          var pMatrix = createOrthoPmatrix();
          var orthoMatrix = createOrthoMatrix( vMatrix, pMatrix );
          ctx.bindUniforms(
            program,
            [
              { name: 'orthoMatrix', type: 'matrix4fv', value: orthoMatrix },
              { name: 'texture',     type: '1i',        value: 0 }
            ]);
        }

        function createOrthoVmatrix() {
          var vMatrix = mat4.identity( mat4.create() );
          mat4.lookAt( vMatrix, [ 0, 0, 0.5 ], [ 0, 0, 0 ], [ 0, 1, 0 ] );
          return vMatrix;
        }

        function createOrthoPmatrix() {
          var pMatrix = mat4.identity( mat4.create() );
          mat4.ortho( pMatrix, -1, 1, 1, -1, 0.1, 1 );
          return pMatrix;
        }

        function createOrthoMatrix( vMatrix, pMatrix ) {
          var orthoMatrix = mat4.identity( mat4.create() );
          mat4.multiply( orthoMatrix, pMatrix, vMatrix );
          return orthoMatrix;
        }

        function calculateQuat( e ) {
          var cw = canvas.width;
          var ch = canvas.height;
          var wh = 1 / Math.sqrt( cw * cw + ch * ch );

          var x      = e.clientX - canvas.offsetLeft - cw * 0.5;
          var y      = e.clientY - canvas.offsetTop  - ch * 0.5;
          var vector = Math.sqrt( x * x + y * y );

          var theta = vector * 2.0 * Math.PI * wh;

          var axis = [ y / vector, x / vector, 0 ];
          quat.setAxisAngle( qt, axis, theta );
        }

        function convertToVec3( dst, q, p ) {
          var r = quat.create();
          quat.invert( r, q );

          var rp   = quat.create();
          quat.multiply( rp, r, p );

          var rpq = quat.create();
          quat.multiply( rpq, rp, q );

          dst[0] = rpq[0];
          dst[1] = rpq[1];
          dst[2] = rpq[2];
        }
      }

      window.onload = main;
    </script>
  </body>
</html>
